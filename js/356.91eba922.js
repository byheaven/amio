"use strict";(self.webpackJsonp=self.webpackJsonp||[]).push([[356],{"5356":function(e,t,n){n.r(t),n.d(t,{"_ExrTextureLoader":function(){return _ExrTextureLoader}});var r=n(658),a=n(7143);const o=65536,s=14,i=65537,l=16384;var c,u;!function(e){e[e.NO_COMPRESSION=0]="NO_COMPRESSION",e[e.RLE_COMPRESSION=1]="RLE_COMPRESSION",e[e.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",e[e.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",e[e.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",e[e.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(c||(c={})),function(e){e[e.INCREASING_Y=0]="INCREASING_Y",e[e.DECREASING_Y=1]="DECREASING_Y"}(u||(u={}));const f=function _GenerateTables(){const e=new ArrayBuffer(4),t=new Float32Array(e),n=new Uint32Array(e),r=new Uint32Array(512),a=new Uint32Array(512);for(let e=0;e<256;++e){const t=e-127;t<-27?(r[e]=0,r[256|e]=32768,a[e]=24,a[256|e]=24):t<-14?(r[e]=1024>>-t-14,r[256|e]=1024>>-t-14|32768,a[e]=-t-1,a[256|e]=-t-1):t<=15?(r[e]=t+15<<10,r[256|e]=t+15<<10|32768,a[e]=13,a[256|e]=13):t<128?(r[e]=31744,r[256|e]=64512,a[e]=24,a[256|e]=24):(r[e]=31744,r[256|e]=64512,a[e]=13,a[256|e]=13)}const o=new Uint32Array(2048),s=new Uint32Array(64),i=new Uint32Array(64);for(let e=1;e<1024;++e){let t=e<<13,n=0;for(;!(8388608&t);)t<<=1,n-=8388608;t&=-8388609,n+=947912704,o[e]=t|n}for(let e=1024;e<2048;++e)o[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)s[e]=e<<23;s[31]=1199570944,s[32]=2147483648;for(let e=33;e<63;++e)s[e]=2147483648+(e-32<<23);s[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(i[e]=1024);return{"floatView":t,"uint32View":n,"baseTable":r,"shiftTable":a,"mantissaTable":o,"exponentTable":s,"offsetTable":i}}();function ParseNullTerminatedString(e,t){const n=new Uint8Array(e);let r=0;for(;0!=n[t.value+r];)r+=1;const a=(new TextDecoder).decode(n.slice(t.value,t.value+r));return t.value=t.value+r+1,a}function ParseInt32(e,t){const n=e.getInt32(t.value,!0);return t.value+=4,n}function ParseUint32(e,t){const n=e.getUint32(t.value,!0);return t.value+=4,n}function ParseUint8(e,t){const n=e.getUint8(t.value);return t.value+=1,n}function ParseUint16(e,t){const n=e.getUint16(t.value,!0);return t.value+=2,n}function ParseUint8Array(e,t){const n=e[t.value];return t.value+=1,n}function ParseInt64(e,t){let n;return n="getBigInt64"in DataView.prototype?Number(e.getBigInt64(t.value,!0)):e.getUint32(t.value+4,!0)+Number(e.getUint32(t.value,!0)<<32),t.value+=8,n}function ParseFloat32(e,t){const n=e.getFloat32(t.value,!0);return t.value+=4,n}function ParseFloat16(e,t){return function DecodeFloat16(e){const t=(31744&e)>>10,n=1023&e;return(e>>15?-1:1)*(t?31===t?n?NaN:1/0:Math.pow(2,t-15)*(1+n/1024):n/1024*6103515625e-14)}(ParseUint16(e,t))}function DecodeFloat32(e,t){return function ToHalfFloat(e){if(Math.abs(e)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");e=(0,a.Lh)(e,-65504,65504),f.floatView[0]=e;const t=f.uint32View[0],n=t>>23&511;return f.baseTable[n]+((8388607&t)>>f.shiftTable[n])}(ParseFloat32(e,t))}function ParseValue(e,t,n,r){switch(n){case"string":case"stringvector":case"iccProfile":return function ParseFixedLengthString(e,t,n){const r=(new TextDecoder).decode(new Uint8Array(e).slice(t.value,t.value+n));return t.value=t.value+n,r}(e.buffer,t,r);case"chlist":return function ParseChlist(e,t,n){const r=t.value,a=[];for(;t.value<r+n-1;){const n=ParseNullTerminatedString(e.buffer,t),r=ParseInt32(e,t),o=ParseUint8(e,t);t.value+=3;const s=ParseInt32(e,t),i=ParseInt32(e,t);a.push({"name":n,"pixelType":r,"pLinear":o,"xSampling":s,"ySampling":i})}return t.value+=1,a}(e,t,r);case"chromaticities":return function ParseChromaticities(e,t){return{"redX":ParseFloat32(e,t),"redY":ParseFloat32(e,t),"greenX":ParseFloat32(e,t),"greenY":ParseFloat32(e,t),"blueX":ParseFloat32(e,t),"blueY":ParseFloat32(e,t),"whiteX":ParseFloat32(e,t),"whiteY":ParseFloat32(e,t)}}(e,t);case"compression":return function ParseCompression(e,t){return ParseUint8(e,t)}(e,t);case"box2i":return function ParseBox2i(e,t){return{"xMin":ParseInt32(e,t),"yMin":ParseInt32(e,t),"xMax":ParseInt32(e,t),"yMax":ParseInt32(e,t)}}(e,t);case"lineOrder":return function ParseLineOrder(e,t){const n=ParseUint8(e,t);return u[n]}(e,t);case"float":return ParseFloat32(e,t);case"v2f":return function ParseV2f(e,t){return[ParseFloat32(e,t),ParseFloat32(e,t)]}(e,t);case"v3f":return function ParseV3f(e,t){return[ParseFloat32(e,t),ParseFloat32(e,t),ParseFloat32(e,t)]}(e,t);case"int":return ParseInt32(e,t);case"rational":return function ParseRational(e,t){return[ParseInt32(e,t),ParseUint32(e,t)]}(e,t);case"timecode":return function ParseTimecode(e,t){return[ParseUint32(e,t),ParseUint32(e,t)]}(e,t);case"preview":return t.value+=r,"skipped";default:return void(t.value+=r)}}function Predictor(e){for(let t=1;t<e.length;t++){const n=e[t-1]+e[t]-128;e[t]=n}}function InterleaveScalar(e,t){let n=0,r=Math.floor((e.length+1)/2),a=0;const o=e.length-1;for(;!(a>o||(t[a++]=e[n++],a>o));)t[a++]=e[r++]}function GetBits(e,t,n,r,a){for(;n<e;)t=t<<8|ParseUint8Array(r,a),n+=8;return{"l":t>>(n-=e)&(1<<e)-1,"c":t,"lc":n}}function GetChar(e,t,n,r){return{"c":e=e<<8|ParseUint8Array(n,r),"lc":t+=8}}function GetCode(e,t,n,r,a,o,s,i,l){if(e==t){if(r<8){const e=GetChar(n,r,a,o);n=e.c,r=e.lc}let e=n>>(r-=8);if(e=new Uint8Array([e])[0],i.value+e>l)return null;const t=s[i.value-1];for(;e-- >0;)s[i.value++]=t}else{if(!(i.value<l))return null;s[i.value++]=e}return{"c":n,"lc":r}}const d=new Array(59);function HufUnpackEncTable(e,t,n,r,a,o){const s=t;let l=0,c=0;for(;r<=a;r++){if(s.value-t.value>n)return;let i=GetBits(6,l,c,e,s);const u=i.l;if(l=i.c,c=i.lc,o[r]=u,63==u){if(s.value-t.value>n)throw new Error("Error in HufUnpackEncTable");i=GetBits(8,l,c,e,s);let u=i.l+6;if(l=i.c,c=i.lc,r+u>a+1)throw new Error("Error in HufUnpackEncTable");for(;u--;)o[r++]=0;r--}else if(u>=59){let e=u-59+2;if(r+e>a+1)throw new Error("Error in HufUnpackEncTable");for(;e--;)o[r++]=0;r--}}!function HufCanonicalCodeTable(e){for(let e=0;e<=58;++e)d[e]=0;for(let t=0;t<i;++t)d[e[t]]+=1;let t=0;for(let e=58;e>0;--e){const n=t+d[e]>>1;d[e]=t,t=n}for(let t=0;t<i;++t){const n=e[t];n>0&&(e[t]=n|d[n]++<<6)}}(o)}function HufLength(e){return 63&e}function HufCode(e){return e>>6}function HufUncompress(e,t,n,r,a,o){const c=n.value,u=ParseUint32(t,n),f=ParseUint32(t,n);n.value+=4;const d=ParseUint32(t,n);if(n.value+=4,u<0||u>=i||f<0||f>=i)throw new Error("Wrong HUF_ENCSIZE");const w=new Array(i),p=new Array(l);!function HufClearDecTable(e){for(let t=0;t<l;t++)e[t]={},e[t].len=0,e[t].lit=0,e[t].p=null}(p);if(HufUnpackEncTable(e,n,r-(n.value-c),u,f,w),d>8*(r-(n.value-c)))throw new Error("Wrong hufUncompress");!function HufBuildDecTable(e,t,n,r){for(;t<=n;t++){const n=HufCode(e[t]),a=HufLength(e[t]);if(n>>a)throw new Error("Invalid table entry");if(a>s){const e=r[n>>a-s];if(e.len)throw new Error("Invalid table entry");if(e.lit++,e.p){const t=e.p;e.p=new Array(e.lit);for(let n=0;n<e.lit-1;++n)e.p[n]=t[n]}else e.p=new Array(1);e.p[e.lit-1]=t}else if(a){let e=0;for(let o=1<<s-a;o>0;o--){const o=r[(n<<s-a)+e];if(o.len||o.p)throw new Error("Invalid table entry");o.len=a,o.lit=t,e++}}}return!0}(w,u,f,p),function HufDecode(e,t,n,r,a,o,i,l,c){let u=0,f=0;const d=i,w=Math.trunc(r.value+(a+7)/8);for(;r.value<w;){let a=GetChar(u,f,n,r);for(u=a.c,f=a.lc;f>=s;){const i=t[u>>f-s&16383];if(i.len){f-=i.len;const e=GetCode(i.lit,o,u,f,n,r,l,c,d);e&&(u=e.c,f=e.lc)}else{if(!i.p)throw new Error("hufDecode issues");let t;for(t=0;t<i.lit;t++){const s=HufLength(e[i.p[t]]);for(;f<s&&r.value<w;)a=GetChar(u,f,n,r),u=a.c,f=a.lc;if(f>=s&&HufCode(e[i.p[t]])==(u>>f-s&(1<<s)-1)){f-=s;const e=GetCode(i.p[t],o,u,f,n,r,l,c,d);e&&(u=e.c,f=e.lc);break}}if(t==i.lit)throw new Error("HufDecode issues")}}}const p=8-a&7;for(u>>=p,f-=p;f>0;){const e=t[u<<s-f&16383];if(!e.len)throw new Error("HufDecode issues");{f-=e.len;const t=GetCode(e.lit,o,u,f,n,r,l,c,d);t&&(u=t.c,f=t.lc)}}return!0}(w,p,e,n,d,f,o,a,{"value":0})}function UInt16(e){return 65535&e}function Int16(e){const t=UInt16(e);return t>32767?t-65536:t}function Wdec14(e,t){const n=Int16(e),r=Int16(t),a=n+(1&r)+(r>>1);return{"a":a,"b":a-r}}function Wdec16(e,t){const n=UInt16(e),r=UInt16(t),a=n-(r>>1)&65535;return{"a":r+a-32768&65535,"b":a}}function Wav2Decode(e,t,n,r,a,o,s){const i=s<16384,l=n>a?a:n;let c,u,f=1;for(;f<=l;)f<<=1;for(f>>=1,c=f,f>>=1;f>=1;){u=0;const s=u+o*(a-c),l=o*f,d=o*c,w=r*f,p=r*c;let h,P,y,b;for(;u<=s;u+=d){let a=u;const o=u+r*(n-c);for(;a<=o;a+=p){const n=a+w,r=a+l,o=r+w;if(i){let s=Wdec14(e[a+t],e[r+t]);h=s.a,y=s.b,s=Wdec14(e[n+t],e[o+t]),P=s.a,b=s.b,s=Wdec14(h,P),e[a+t]=s.a,e[n+t]=s.b,s=Wdec14(y,b),e[r+t]=s.a,e[o+t]=s.b}else{let s=Wdec16(e[a+t],e[r+t]);h=s.a,y=s.b,s=Wdec16(e[n+t],e[o+t]),P=s.a,b=s.b,s=Wdec16(h,P),e[a+t]=s.a,e[n+t]=s.b,s=Wdec16(y,b),e[r+t]=s.a,e[o+t]=s.b}}if(n&f){const n=a+l;let r;r=i?Wdec14(e[a+t],e[n+t]):Wdec16(e[a+t],e[n+t]),h=r.a,e[n+t]=r.b,e[a+t]=h}}if(a&f){let a=u;const o=u+r*(n-c);for(;a<=o;a+=p){const n=a+w;let r;r=i?Wdec14(e[a+t],e[n+t]):Wdec16(e[a+t],e[n+t]),h=r.a,e[n+t]=r.b,e[a+t]=h}}c=f,f>>=1}return u}function UncompressRAW(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function UncompressRLE(e){const t=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),n=new Uint8Array(function DecodeRunLength(e){let t=e.byteLength;const n=new Array;let r=0;const a=new DataView(e);for(;t>0;){const e=a.getInt8(r++);if(e<0){const o=-e;t-=o+1;for(let e=0;e<o;e++)n.push(a.getUint8(r++))}else{const o=e;t-=2;const s=a.getUint8(r++);for(let e=0;e<o+1;e++)n.push(s)}}return n}(t)),r=new Uint8Array(n.length);return Predictor(n),InterleaveScalar(n,r),new DataView(r.buffer)}function UncompressZIP(e){const t=e.array.slice(e.offset.value,e.offset.value+e.size),n=fflate.unzlibSync(t),r=new Uint8Array(n.length);return Predictor(n),InterleaveScalar(n,r),new DataView(r.buffer)}function UncompressPXR(e){const t=e.array.slice(e.offset.value,e.offset.value+e.size),n=fflate.unzlibSync(t),r=e.lines*e.channels*e.width,a=1==e.type?new Uint16Array(r):new Uint32Array(r);let o=0,s=0;const i=new Array(4);for(let t=0;t<e.lines;t++)for(let t=0;t<e.channels;t++){let t=0;switch(e.type){case 1:i[0]=o,i[1]=i[0]+e.width,o=i[1]+e.width;for(let r=0;r<e.width;++r){t+=n[i[0]++]<<8|n[i[1]++],a[s]=t,s++}break;case 2:i[0]=o,i[1]=i[0]+e.width,i[2]=i[1]+e.width,o=i[2]+e.width;for(let r=0;r<e.width;++r){t+=n[i[0]++]<<24|n[i[1]++]<<16|n[i[2]++]<<8,a[s]=t,s++}}}return new DataView(a.buffer)}function UncompressPIZ(e){const t=e.viewer,n={"value":e.offset.value},r=new Uint16Array(e.width*e.scanlineBlockSize*(e.channels*e.type)),a=new Uint8Array(8192);let s=0;const i=new Array(e.channels);for(let t=0;t<e.channels;t++)i[t]={},i[t].start=s,i[t].end=i[t].start,i[t].nx=e.width,i[t].ny=e.lines,i[t].size=e.type,s+=i[t].nx*i[t].ny*i[t].size;const l=ParseUint16(t,n),c=ParseUint16(t,n);if(c>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(l<=c)for(let e=0;e<c-l+1;e++)a[e+l]=ParseUint8(t,n);const u=new Uint16Array(o),f=function ReverseLutFromBitmap(e,t){let n=0;for(let r=0;r<o;++r)(0==r||e[r>>3]&1<<(7&r))&&(t[n++]=r);const r=n-1;for(;n<o;)t[n++]=0;return r}(a,u),d=ParseUint32(t,n);HufUncompress(e.array,t,n,d,r,s);for(let t=0;t<e.channels;++t){const e=i[t];for(let n=0;n<i[t].size;++n)Wav2Decode(r,e.start+n,e.nx,e.size,e.ny,e.nx*e.size,f)}!function ApplyLut(e,t,n){for(let r=0;r<n;++r)t[r]=e[t[r]]}(u,r,s);let w=0;const p=new Uint8Array(r.buffer.byteLength);for(let t=0;t<e.lines;t++)for(let t=0;t<e.channels;t++){const e=i[t],n=e.nx*e.size,a=new Uint8Array(r.buffer,2*e.end,2*n);p.set(a,w),w+=2*n,e.end+=n}return new DataView(p.buffer)}var w,p=n(8658);!function(e){e[e.Float=0]="Float",e[e.HalfFloat=1]="HalfFloat"}(w||(w={}));class ExrLoaderGlobalConfiguration{}ExrLoaderGlobalConfiguration.DefaultOutputType=w.HalfFloat,ExrLoaderGlobalConfiguration.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class _ExrTextureLoader{"constructor"(){this.supportCascades=!1}"loadCubeData"(e,t,n,r,a){throw".exr not supported in Cube."}async"loadData"(e,t,n){const a=new DataView(e.buffer),o={"value":0},s=function GetExrHeader(e,t){if(20000630!=e.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const n=e.getUint8(4),a=e.getUint8(5),o={"singleTile":!!(2&a),"longName":!!(4&a),"deepFormat":!!(8&a),"multiPart":!!(16&a)};t.value=8;const s={};let i=!0;for(;i;){const n=ParseNullTerminatedString(e.buffer,t);if(n){const a=ParseNullTerminatedString(e.buffer,t),o=ParseValue(e,t,a,ParseUint32(e,t));void 0===o?r.Y.Warn(`Unknown header attribute type ${a}'.`):s[n]=o}else i=!1}if(-5&a)throw new Error("Unsupported file format");return{"version":n,"spec":o,...s}}(a,o),i=await async function CreateDecoderAsync(e,t,n,r){const a={"size":0,"viewer":t,"array":new Uint8Array(t.buffer),"offset":n,"width":e.dataWindow.xMax-e.dataWindow.xMin+1,"height":e.dataWindow.yMax-e.dataWindow.yMin+1,"channels":e.channels.length,"channelLineOffsets":{},"scanOrder":()=>0,"bytesPerLine":0,"outLineWidth":0,"lines":0,"scanlineBlockSize":0,"inputSize":null,"type":0,"uncompress":null,"getter":()=>0,"format":5,"outputChannels":0,"decodeChannels":{},"blockCount":null,"byteArray":null,"linearSpace":!1,"textureType":0};switch(e.compression){case c.NO_COMPRESSION:a.lines=1,a.uncompress=UncompressRAW;break;case c.RLE_COMPRESSION:a.lines=1,a.uncompress=UncompressRLE;break;case c.ZIPS_COMPRESSION:a.lines=1,a.uncompress=UncompressZIP,await p.w1.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);break;case c.ZIP_COMPRESSION:a.lines=16,a.uncompress=UncompressZIP,await p.w1.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);break;case c.PIZ_COMPRESSION:a.lines=32,a.uncompress=UncompressPIZ;break;case c.PXR24_COMPRESSION:a.lines=16,a.uncompress=UncompressPXR,await p.w1.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);break;default:throw new Error(c[e.compression]+" is unsupported")}a.scanlineBlockSize=a.lines;const o={};for(const t of e.channels)switch(t.name){case"Y":case"R":case"G":case"B":case"A":o[t.name]=!0,a.type=t.pixelType}let s=!1;if(o.R&&o.G&&o.B)s=!o.A,a.outputChannels=4,a.decodeChannels={"R":0,"G":1,"B":2,"A":3};else{if(!o.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");a.outputChannels=1,a.decodeChannels={"Y":0}}if(1===a.type)switch(r){case w.Float:a.getter=ParseFloat16,a.inputSize=2;break;case w.HalfFloat:a.getter=ParseUint16,a.inputSize=2}else{if(2!==a.type)throw new Error("Unsupported pixelType "+a.type+" for "+e.compression);switch(r){case w.Float:a.getter=ParseFloat32,a.inputSize=4;break;case w.HalfFloat:a.getter=DecodeFloat32,a.inputSize=4}}a.blockCount=a.height/a.scanlineBlockSize;for(let e=0;e<a.blockCount;e++)ParseInt64(t,n);const i=a.width*a.height*a.outputChannels;switch(r){case w.Float:a.byteArray=new Float32Array(i),a.textureType=1,s&&a.byteArray.fill(1,0,i);break;case w.HalfFloat:a.byteArray=new Uint16Array(i),a.textureType=2,s&&a.byteArray.fill(15360,0,i);break;default:throw new Error("Unsupported type: "+r)}let l=0;for(const t of e.channels)void 0!==a.decodeChannels[t.name]&&(a.channelLineOffsets[t.name]=l*a.width),l+=2*t.pixelType;return a.bytesPerLine=a.width*l,a.outLineWidth=a.width*a.outputChannels,"INCREASING_Y"===e.lineOrder?a.scanOrder=e=>e:a.scanOrder=e=>a.height-1-e,4==a.outputChannels?(a.format=5,a.linearSpace=!0):(a.format=6,a.linearSpace=!1),a}(s,a,o,ExrLoaderGlobalConfiguration.DefaultOutputType);!function ScanData(e,t,n,r){const a={"value":0};for(let o=0;o<e.height/e.scanlineBlockSize;o++){const s=ParseInt32(n,r)-t.dataWindow.yMin;e.size=ParseUint32(n,r),e.lines=s+e.scanlineBlockSize>e.height?e.height-s:e.scanlineBlockSize;const i=e.size<e.lines*e.bytesPerLine&&e.uncompress?e.uncompress(e):UncompressRAW(e);r.value+=e.size;for(let n=0;n<e.scanlineBlockSize;n++){const r=o*e.scanlineBlockSize,s=n+e.scanOrder(r);if(s>=e.height)continue;const l=n*e.bytesPerLine,c=(e.height-1-s)*e.outLineWidth;for(let n=0;n<e.channels;n++){const r=t.channels[n].name,o=e.channelLineOffsets[r],s=e.decodeChannels[r];if(void 0!==s){a.value=l+o;for(let t=0;t<e.width;t++){const n=c+t*e.outputChannels+s;e.byteArray&&(e.byteArray[n]=e.getter(i,a))}}}}}}(i,s,a,o);n(s.dataWindow.xMax-s.dataWindow.xMin+1,s.dataWindow.yMax-s.dataWindow.yMin+1,t.generateMipMaps,!1,()=>{const e=t.getEngine();t.format=s.format,t.type=i.textureType,t.invertY=!1,t._gammaSpace=!s.linearSpace,i.byteArray&&e._uploadDataToTextureDirectly(t,i.byteArray,0,0,void 0,!0)})}}}}]);